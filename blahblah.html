<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Phaser â€“ Hill with Rolling Bot (Fixed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
  <style>html,body{margin:0;background:#0b0f14}</style>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 960,
  height: 540,
  backgroundColor: '#028383',
  physics: {
    default: 'arcade',
    arcade: { gravity: { y: 900 }, debug: false }
  },
  scene: { preload, create, update }
};
new Phaser.Game(config);

let player, bot, ground, hill;
let cursors, aKey, dKey, wKey, spaceKey, escKey;
let canMove = true;
let dialogOpen = false;
let nearPrompt, dialogGroup;

let canDoubleJump = false;
let jumpKey;

// rolling bot patrol (on the hill)
const botPatrol = {
  minX: 320,
  maxX: 820,
  speed: 90
};

function preload() {
  // Player texture (green)
  const g1 = this.add.graphics();
  g1.fillStyle(0x3ad97a,1).fillRoundedRect(0,0,24,36,6);
  g1.lineStyle(2,0x1b6138,1).strokeRoundedRect(0,0,24,36,6);
  g1.generateTexture('playerTex',24,36); g1.destroy();

  // Bot texture (blue circle)
  const g2 = this.add.graphics();
  g2.fillStyle(0x3aa1ff,1).fillCircle(16,16,16);
  g2.lineStyle(3,0x124a84,1).strokeCircle(16,16,16);
  g2.generateTexture('botTex',32,32); g2.destroy();

  // Ground tile (grey)
  const g3 = this.add.graphics();
  g3.fillStyle(0x4b5c6b,1).fillRect(0,0,48,24);
  g3.lineStyle(2,0x2c3640,1).strokeRect(0,0,48,24);
  g3.generateTexture('tile',48,24); g3.destroy();
}

function create() {
  const W = this.scale.width;
  const H = this.scale.height;

  // --- 1) FLAT GROUND ---
  ground = this.physics.add.staticGroup();
  for (let x = 0; x < W; x += 48) {
    ground.create(x + 24, H - 20, 'tile').refreshBody();
  }

  // --- 2) HILL MADE OF STEPS (slight overlap so no gaps) ---
  hill = this.physics.add.staticGroup();
  const baseY = H - 56; // top of the flat ground area
  let x = 320;
  // slope up (8 steps)
  for (let i = 0; i < 8; i++) {
    const step = hill.create(x, baseY - i * 10, 'tile');
    step.refreshBody();
    x += 40; // 40 < tile width (48) so they overlap slightly
  }
  // short flat top (4 tiles)
  for (let i = 0; i < 4; i++) {
    const step = hill.create(x, baseY - 7 * 10, 'tile');
    step.refreshBody();
    x += 40;
  }

  // --- 3) PLAYER ---
  player = this.physics.add.sprite(80, baseY - 80, 'playerTex');
  player.setCollideWorldBounds(true);
  player.body.setSize(20,34).setOffset(2,2);
  player.setDragX(1000);

  // --- 4) BOT: spawn ABOVE the hill so it falls neatly onto it ---
  bot = this.physics.add.sprite((botPatrol.minX + botPatrol.maxX)/2, baseY - 200, 'botTex');
  bot.setCollideWorldBounds(false); // allow it to roll off-screen; weâ€™ll respawn it
  bot.setBounce(0);
  bot.body.setCircle(16);
  bot.body.setOffset(0,0);
  bot.setVelocityX(botPatrol.speed);

  // Collisions
  this.physics.add.collider(player, ground);
  this.physics.add.collider(player, hill);
  this.physics.add.collider(bot, ground);
  this.physics.add.collider(bot, hill);

  // Controls
  cursors = this.input.keyboard.createCursorKeys();
  aKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
  dKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
  wKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.w);
  jumpKey = spaceKey; // use space to jump

  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
  escKey   = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ESC);

  // Hint text
  nearPrompt = this.add.text(0,0,'SPACE to talk',{
    fontFamily:'Arial', fontSize:'16px', color:'#fff',
    backgroundColor:'#1a2733', padding:{left:8,right:8,top:4,bottom:4}
  }).setAlpha(0).setDepth(1000);

  // Dialog UI
  dialogGroup = this.add.container(W/2, 120).setDepth(1500).setVisible(false);
  const panel = this.add.rectangle(0,0, 420, 130, 0x0f1822, 0.96)
                  .setStrokeStyle(2, 0x3aa1ff, 1).setOrigin(0.5);
  const txt1  = this.add.text(0,-26, 'ðŸ¤– Bot: What do you want?', {
                  fontFamily:'Arial', fontSize:'20px', color:'#ffffff'
                }).setOrigin(0.5);
  const txt2  = this.add.text(0,12, 'SPACE: Continue   â€¢   ESC: Cancel', {
                  fontFamily:'Arial', fontSize:'16px', color:'#b7c9d3'
                }).setOrigin(0.5);
  dialogGroup.add([panel, txt1, txt2]);

  // Open / close dialog
  wKey.on('down', () => {
    if (isCloseToBot() && !dialogOpen) openDialog.call(this);
    else if (dialogOpen) closeDialog();
  });
  escKey.on('down', () => { if (dialogOpen) closeDialog(); });

  // Camera
  this.cameras.main.startFollow(player, true, 0.15, 0.15);
  this.cameras.main.setBounds(0,0,W,H);
}

function update() {
  const onGround = player.body.blocked.down || player.body.touching.down;

  // Reset double-jump when landed
  if (onGround) canDoubleJump = true;

  // --- Player movement ---
  if (canMove) {
    const speed = 220;
    if (cursors.left.isDown || aKey.isDown)      player.setVelocityX(-speed);
    else if (cursors.right.isDown || dKey.isDown)player.setVelocityX(speed);
    else                                         player.setVelocityX(0);

    // Double jump
    if (Phaser.Input.Keyboard.JustDown(jumpKey)) {
      if (onGround) {
        player.setVelocityY(-420);
        canDoubleJump = true;
      } else if (canDoubleJump) {
        player.setVelocityY(-820);
        canDoubleJump = false;
      }
    }
  } else {
    player.setVelocityX(0);
  }

  // --- Rolling bot behaviour ---
  if (!dialogOpen) {
    const bOnGround = bot.body.blocked.down || bot.body.touching.down;

    // Reverse direction at patrol edges
    if (bot.x <= botPatrol.minX && bot.body.velocity.x < 0) {
      bot.setVelocityX(botPatrol.speed);
    } else if (bot.x >= botPatrol.maxX && bot.body.velocity.x > 0) {
      bot.setVelocityX(-botPatrol.speed);
    }

    // If bot is on the ground but slowed down a lot, nudge it
    if (bOnGround && Math.abs(bot.body.velocity.x) < 5) {
      const dir = (bot.x < (botPatrol.minX + botPatrol.maxX)/2) ? 1 : -1;
      bot.setVelocityX(dir * botPatrol.speed);
    }

    // If bot somehow falls off the world, respawn on hill
    const H = this.scale.height;
    if (bot.y > H + 50) {
      respawnBotOnHill();
    }

    // Spin visual
    bot.rotation += bot.body.velocity.x * 0.0008;
  } else {
    bot.setVelocityX(0);
  }

  // Hint: show when close to bot and not in dialog
  if (!dialogOpen && isCloseToBot()) {
    nearPrompt.setPosition(bot.x, bot.y - 48).setAlpha(0.95);
  } else {
    nearPrompt.setAlpha(0);
  }
}

/* ------------ Helpers ------------ */

function respawnBotOnHill() {
  const H = config.height;
  const baseY = H - 56;
  bot.setPosition((botPatrol.minX + botPatrol.maxX)/2, baseY - 180);
  bot.setVelocityX(botPatrol.speed);
  bot.setVelocityY(0);
}

function isCloseToBot() {
  const dx = Math.abs(player.x - bot.x);
  const dy = Math.abs(player.y - bot.y);
  return dx < 40 && dy < 60;
}

function openDialog() {
  canMove = false;
  dialogOpen = true;
  dialogGroup.setVisible(true);
  this.tweens.add({
    targets: dialogGroup,
    scale: { from: 0.9, to: 1 },
    alpha: { from: 0, to: 1 },
    duration: 120
  });
}

function closeDialog() {
  dialogOpen = false;
  dialogGroup.setVisible(false);
  canMove = true;
}
</script>
</body>
</html>

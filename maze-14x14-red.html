<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Phaser Maze â€“ Fully Explained for Students</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
<style>html,body{margin:0;background:#111;overflow:hidden}</style>
</head>
<body>
<script>
/*
ðŸŽ® MAZE GAME â€“ EXPLAINED STEP BY STEP ðŸŽ®
---------------------------------------
This game builds a random maze, puts a red player square at the bottom,
and lets you move around using the WASD or arrow keys.

ðŸ‘‰ You can:
  - Click â€œEasy Mazeâ€ for a short route to the top.
  - Click â€œDifficult Mazeâ€ for a twisty long route.
  - Click â€œShow Pathâ€ to reveal the fastest way to escape.

All of this is drawn using Phaser, a 2D game engine for JavaScript.
*/


/* =========================
   ðŸŽ¨ BASIC SETTINGS
   ========================= */
const COLS = 15, ROWS = 15;     // The maze is 15 cells wide and tall (path cells only)
const GW   = 2*COLS + 1;        // Full grid width (with walls between cells)
const GH   = 2*ROWS + 1;        // Full grid height

// Make the game window (the "canvas" where Phaser draws)
new Phaser.Game({
  type: Phaser.AUTO,             // Phaser picks the best renderer (WebGL or Canvas)
  width: 940,                    // Width of the game area in pixels
  height: 720,                   // Height of the game area
  backgroundColor: '#111',       // Dark grey background
  scene: { create, update }      // The 2 main Phaser functions we'll use
});

// Variables weâ€™ll fill later
let scene, gfxMaze, gfxPath, W, H;
let grid, startGate, endGate;
let TILE = 20;                  // Size of each maze tile (weâ€™ll scale this later)
const PAD_X = 60, PAD_Y = 100;  // Padding around maze edges
const UI_H  = 64;               // Space for the text and buttons at the top
let offX = 0, offY = 0;         // Offset values to center the maze

// Player and controls
let player, pg={x:0,y:0}, moving=false, keys, showPath=false;


/* =========================
   ðŸ§± PHASER CREATE FUNCTION
   ========================= */
function create(){
  scene = this;             // "this" is the scene itself
  W = this.scale.width;     // width of the screen
  H = this.scale.height;    // height of the screen

  // Create drawing layers: one for maze, one for path overlay
  gfxMaze = this.add.graphics();
  gfxPath = this.add.graphics();

  // Title text
  this.add.text(20, 14, 'WASD/Arrows â€¢ Easy/Difficult â€¢ Show Path (R to randomise)',
    { fontFamily:'Arial Black', fontSize:16, color:'#ddd' });

  // Buttons (weâ€™ll make them using our custom function below)
  makeBtn(W-480, 34, 120, 36, 'Easy Maze',      () => rebuild('easy'));
  makeBtn(W-340, 34, 140, 36, 'Difficult Maze', () => rebuild('hard'));
  makeBtn(W-160, 34, 110, 36, 'Show Path',      () => { showPath = !showPath; drawPath(); });

  // R key quickly randomises a maze
  this.input.keyboard.on('keydown-R', () => rebuild('normal'));

  // WASD and arrow keys
  keys = this.input.keyboard.addKeys({W:'W',A:'A',S:'S',D:'D',UP:'UP',LEFT:'LEFT',DOWN:'DOWN',RIGHT:'RIGHT'});

  // Build the first maze straight away
  rebuild('normal');
}


/* =========================
   ðŸ” PHASER UPDATE LOOP
   ========================= */
function update(){
  // This runs about 60 times per second
  if (moving) return; // stop if the player is already sliding between tiles

  let dx=0, dy=0; // direction weâ€™ll move
  // Check if a key was pressed this frame
  if (Phaser.Input.Keyboard.JustDown(keys.W) || Phaser.Input.Keyboard.JustDown(keys.UP))    dy=-1;
  else if (Phaser.Input.Keyboard.JustDown(keys.S) || Phaser.Input.Keyboard.JustDown(keys.DOWN)) dy= 1;
  else if (Phaser.Input.Keyboard.JustDown(keys.A) || Phaser.Input.Keyboard.JustDown(keys.LEFT)) dx=-1;
  else if (Phaser.Input.Keyboard.JustDown(keys.D) || Phaser.Input.Keyboard.JustDown(keys.RIGHT))dx= 1;

  // Try to move if we pressed something
  if (dx||dy) tryMove(dx,dy);
}


/* =========================
   ðŸš¶ PLAYER MOVEMENT
   ========================= */
function tryMove(dx,dy){
  // Calculate where the player wants to go
  const nx = pg.x + dx, ny = pg.y + dy;

  // Only move if itâ€™s inside the maze and not a wall (1 = wall, 0 = open)
  if (ny>=0 && ny<GH && nx>=0 && nx<GW && grid[ny][nx]===0){
    moving = true;
    pg.x = nx; pg.y = ny;
    const p = toPx(nx, ny); // convert grid coords to screen coords
    scene.tweens.add({
      targets: player, x: p.x, y: p.y, duration: 110, ease: 'Sine.easeOut',
      onComplete: ()=>{ moving=false; if (showPath) drawPath(); }
    });
  }
}


/* =========================
   ðŸ§® BUILD / CENTER THE MAZE
   ========================= */
function computeLayout(){
  // Calculate how big each TILE should be so the full maze fits on screen
  const availW = W - PAD_X*2;
  const availH = (H - UI_H) - PAD_Y*2;
  TILE = Math.floor(Math.min(availW / GW, availH / GH));
  TILE = Math.max(10, TILE); // Donâ€™t go smaller than 10 pixels

  // Figure out where to draw the maze so it's perfectly centered
  const mazeWpx = GW * TILE;
  const mazeHpx = GH * TILE;
  offX = Math.floor((W - mazeWpx)/2);
  offY = Math.floor(UI_H + (H - UI_H - mazeHpx)/2);
}


/* =========================
   ðŸ”„ REBUILD (MAKE A NEW MAZE)
   ========================= */
function rebuild(mode){
  computeLayout(); // find perfect size and position first

  // Create a new maze grid
  const gen = generateMaze(COLS, ROWS, mode);
  grid = gen.grid; startGate = gen.start; endGate = gen.end;

  // Draw it on screen
  drawMaze();

  // Place the red player near the bottom exit
  pg = { x: endGate.x, y: GH - 2 };
  const p = toPx(pg.x, pg.y);

  // Create player if first time, else just move it
  if (!player){
    player = scene.add.rectangle(p.x, p.y, TILE-8, TILE-8, 0xff2b2b)
      .setStrokeStyle(2, 0xffffff)
      .setDepth(1000);
  } else {
    player.setPosition(p.x, p.y);
  }

  gfxPath.clear();
  showPath = false;
}


/* =========================
   ðŸŽ¨ DRAWING THE MAZE
   ========================= */
function drawMaze(){
  gfxMaze.clear();

  // Step 1: draw a white square background (the walls)
  gfxMaze.fillStyle(0xffffff, 1);
  gfxMaze.fillRect(offX, offY, GW*TILE, GH*TILE);

  // Step 2: fill in the floor tiles (dark brown)
  gfxMaze.fillStyle(0x2b2118, 1);
  for (let y=0;y<GH;y++) for (let x=0;x<GW;x++) if (grid[y][x]===0)
    gfxMaze.fillRect(offX + x*TILE, offY + y*TILE, TILE, TILE);

  // Step 3: draw the start and end gates (blue)
  gfxMaze.fillStyle(0x24b2ff, 1);
  gfxMaze.fillRect(offX + startGate.x*TILE, offY + startGate.y*TILE, TILE, TILE);
  gfxMaze.fillRect(offX + endGate.x*TILE,   offY + endGate.y*TILE,   TILE, TILE);

  // Step 4: outline the whole maze with a border
  gfxMaze.lineStyle(4, 0xffffff, 1);
  gfxMaze.strokeRect(offX, offY, GW*TILE, GH*TILE);
}


/* =========================
   ðŸŸ¡ SHOW SHORTEST PATH
   ========================= */
function drawPath(){
  gfxPath.clear(); if (!showPath) return;

  // Weâ€™ll find the shortest path using a search (BFS)
  const start={x:pg.x,y:pg.y}, goal={x:startGate.x,y:1};
  const q=[start]; // queue of spots to check
  const prev=new Map(); // stores where we came from
  const key=(x,y)=>`${x},${y}`;
  prev.set(key(start.x,start.y),null);

  // BFS: explore neighbours until we reach the goal
  while(q.length){
    const c=q.shift();
    if(c.x===goal.x&&c.y===goal.y)break; // reached top!
    for(const[dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const nx=c.x+dx, ny=c.y+dy;
      if(ny>=0&&ny<GH&&nx>=0&&nx<GW&&grid[ny][nx]===0){
        const k=key(nx,ny);
        if(!prev.has(k)){prev.set(k,c); q.push({x:nx,y:ny});}
      }
    }
  }

  // Rebuild path by walking backwards from goal to start
  const path=[]; let ck=key(goal.x,goal.y);
  if(!prev.has(ck)) return;
  while(ck){
    const[x,y]=ck.split(',').map(Number);
    path.push({x,y});
    const p=prev.get(ck);
    ck=p?key(p.x,p.y):null;
  }

  // Draw small yellow dots along the route
  gfxPath.fillStyle(0xffe666,1);
  path.forEach(c=>{
    const p=toPx(c.x,c.y);
    gfxPath.fillCircle(p.x,p.y, Math.max(3, Math.floor(TILE/8)));
  });
}


/* =========================
   ðŸ§  MAZE GENERATOR
   =========================
This uses a "depth-first search" algorithm.

It starts from a random cell, moves to new neighbours,
and "carves" passages between cells by removing walls.
When it runs out of options, it backtracks until the maze is full.
*/
function generateMaze(cols,rows,mode){
  const g = Array.from({length:GH},()=>Array(GW).fill(1)); // 1 = wall
  const vis = Array.from({length:rows},()=>Array(cols).fill(false));

  // Pick a random starting cell
  const st = {x:Phaser.Math.Between(0,cols-1), y:Phaser.Math.Between(0,rows-1)};
  const stack=[st];
  vis[st.y][st.x]=true;
  g[st.y*2+1][st.x*2+1]=0;

  // Main carving loop
  while(stack.length){
    const c=stack[stack.length-1];
    const nbs=[]; // possible next cells

    // Look up/down/left/right for unvisited neighbours
    if(c.y>0        && !vis[c.y-1][c.x]) nbs.push({x:c.x,y:c.y-1});
    if(c.y<rows-1   && !vis[c.y+1][c.x]) nbs.push({x:c.x,y:c.y+1});
    if(c.x>0        && !vis[c.y][c.x-1]) nbs.push({x:c.x-1,y:c.y});
    if(c.x<cols-1   && !vis[c.y][c.x+1]) nbs.push({x:c.x+1,y:c.y});

    if(nbs.length){
      // Pick a neighbour
      let nb;
      if(mode==='easy')      nb = Phaser.Utils.Array.GetRandom(nbs.sort((a,b)=>a.y-b.y));  // bias upward
      else if(mode==='hard') nb = Phaser.Utils.Array.GetRandom(nbs.sort((a,b)=>b.y-a.y));  // bias downward
      else                   nb = Phaser.Utils.Array.GetRandom(nbs);                      // random

      // Knock down the wall between them
      const gx=c.x*2+1, gy=c.y*2+1, nx=nb.x*2+1, ny=nb.y*2+1;
      g[(gy+ny)/2][(gx+nx)/2]=0; // middle wall removed
      g[ny][nx]=0;               // mark new cell as open

      vis[nb.y][nb.x]=true;
      stack.push(nb);
    } else {
      // No options left? Backtrack
      stack.pop();
    }
  }

  // Create solid borders and one opening at top/bottom
  for(let x=0;x<GW;x++){ g[0][x]=1; g[GH-1][x]=1; }
  for(let y=0;y<GH;y++){ g[y][0]=1; g[y][GW-1]=1; }
  const tops=[], bots=[];
  for(let x=1;x<GW-1;x+=2){ if(g[1][x]===0) tops.push(x); if(g[GH-2][x]===0) bots.push(x); }
  const topX = Phaser.Utils.Array.GetRandom(tops) ?? 1;
  const botX = Phaser.Utils.Array.GetRandom(bots) ?? (GW-2);
  g[0][topX]=0; g[GH-1][botX]=0;

  return { grid:g, start:{x:topX,y:0}, end:{x:botX,y:GH-1} };
}


/* =========================
   ðŸ§® HELPER FUNCTIONS
   ========================= */

// Converts maze grid coordinates (x,y) into screen pixels
function toPx(gx,gy){
  return { x: offX + gx*TILE + TILE/2, y: offY + gy*TILE + TILE/2 };
}

// Draws nice green buttons at the top
function makeBtn(x,y,w,h,label,fn){
  const g=scene.add.graphics({x:x-w/2,y:y-h/2});
  drawBtn(g,w,h,false);
  scene.add.text(x,y,label,{fontFamily:'Arial',fontSize:16,color:'#fff'}).setOrigin(0.5);
  scene.add.zone(x,y,w,h).setInteractive({useHandCursor:true})
    .on('pointerover',()=>drawBtn(g,w,h,true))
    .on('pointerout', ()=>drawBtn(g,w,h,false))
    .on('pointerdown',fn);
}

// Changes the button colour when hovered
function drawBtn(g,w,h,hover){
  g.clear();
  g.fillStyle(hover?0x009a70:0x006e51,1);
  g.fillRoundedRect(0,0,w,h,8);
  g.lineStyle(2,0xe6d971,1);
  g.strokeRoundedRect(0,0,w,h,8);
}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Phaser Matter â€“ Planet Weak Spot Break</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 900,
  height: 560,
  backgroundColor: '#0b1020',
  physics: {
    default: 'matter',
    matter: {
      gravity: { y: 0 },   // spacey feel; debris floats unless nudged
      debug: false
    }
  },
  scene: { preload, create, update }
};

new Phaser.Game(config);

let planetSprite, planetBody;
let info, msg;
const planet = { x: 450, y: 280, r: 120 };
const weak = {  // define a "weak sector" on the planet (angles in radians)
  start: Phaser.Math.DegToRad(310),  // ~10 o'clock to 2 o'clock sector (tweak if you want)
  end:   Phaser.Math.DegToRad(350),
  rimOnly: true                      // require click near rim (not centre)
};
let brokenOnce = false;

function preload(){}

function create(){
  // --- Draw a planet texture ---
  const g = this.add.graphics();
  // base
  g.fillStyle(0x2962ff, 1);
  g.fillCircle(planet.x, planet.y, planet.r);
  // a soft highlight
  g.fillStyle(0x5c9eff, 0.45);
  g.fillCircle(planet.x - planet.r*0.35, planet.y - planet.r*0.35, planet.r*0.6);
  // a darker limb
  g.lineStyle(8, 0x142f66, 0.65);
  g.strokeCircle(planet.x, planet.y, planet.r);

  // Bake into a texture so we can have a single sprite with a physics body
  const key = 'planet';
  g.generateTexture(key, config.width, config.height);
  g.destroy();
  planetSprite = this.add.image(0, 0, key).setOrigin(0,0);

  // --- Planet physics body (single circle) ---
  planetBody = this.matter.add.circle(planet.x, planet.y, planet.r, {
    isStatic: true
  });

  // HUD
  info = this.add.text(16, 16,
    'Click the planet. Only a specific rim sector is fragile.\nHit that spot to break off debris.',
    { fontFamily:'Arial, Helvetica, sans-serif', fontSize:'16px', color:'#bfe6ff' }
  );
  msg = this.add.text(16, 50, '', {
    fontFamily:'Arial, Helvetica, sans-serif', fontSize:'16px', color:'#ffd166'
  });

  // visualize weak sector (subtle)
  drawWeakSector.call(this);

  // Pointer handler
  this.input.on('pointerdown', (pointer) => {
    const pt = { x: pointer.x, y: pointer.y };
    if (isOnPlanet(pt)) {
      if (!brokenOnce && isInWeakSpot(pt)) {
        brokenOnce = true;
        msg.setText('ðŸ’¥ Weak spot hit! Fragmentingâ€¦');
        spawnDebris(this, pt);
        drawCrater(this, pt);
      } else {
        msg.setText('â€¦thud (no effect)');
        // optional: small flash at click
        thudFlash(this, pt);
      }
    } else {
      msg.setText('');
    }
  });
}

function update(){}

/* ---------------- Helpers ---------------- */

function isOnPlanet(pt){
  const d = Phaser.Math.Distance.Between(pt.x, pt.y, planet.x, planet.y);
  return d <= planet.r + 2;
}

function isInWeakSpot(pt){
  // angle of click relative to planet centre
  const ang = Phaser.Math.Angle.Normalize(Math.atan2(pt.y - planet.y, pt.x - planet.x));
  const inArc = angleWithin(ang, weak.start, weak.end);
  if (!inArc) return false;

  if (weak.rimOnly){
    // require click to be close to the rim (outer 25% band)
    const d = Phaser.Math.Distance.Between(pt.x, pt.y, planet.x, planet.y);
    return d > planet.r * 0.75;
  }
  return true;
}

// Handles wrap-around of angles near 0/2Ï€
function angleWithin(a, start, end){
  let s = start, e = end, x = a;
  if (e < s) e += Math.PI * 2;
  if (x < s) x += Math.PI * 2;
  return x >= s && x <= e;
}

function spawnDebris(scene, pt){
  // Direction from planet centre to impact point
  const dir = new Phaser.Math.Vector2(pt.x - planet.x, pt.y - planet.y).normalize();

  // --- Big chunk (a triangle-ish shard) ---
  const shardSize = 40;
  const nx = dir.x, ny = dir.y;
  // make a little triangular polygon pointing outward
  const baseL = rotateVec(nx, ny, +Math.PI/2).scale(shardSize*0.6);
  const baseR = rotateVec(nx, ny, -Math.PI/2).scale(shardSize*0.6);
  const tip = new Phaser.Math.Vector2(nx, ny).scale(shardSize*1.4);

  const verts = [
    { x: pt.x + baseL.x, y: pt.y + baseL.y },
    { x: pt.x + baseR.x, y: pt.y + baseR.y },
    { x: pt.x + tip.x,   y: pt.y + tip.y }
  ];
  const shard = scene.matter.add.fromVertices(pt.x, pt.y, [verts], {
    restitution: 0.1, friction: 0.2, frictionAir: 0.01, density: 0.001
  });
  // paint the shard
  const sg = scene.add.graphics();
  sg.fillStyle(0x9bc9ff, 1);
  sg.lineStyle(2, 0x4a7fd3, 1);
  sg.beginPath();
  sg.moveTo(verts[0].x, verts[0].y);
  sg.lineTo(verts[1].x, verts[1].y);
  sg.lineTo(verts[2].x, verts[2].y);
  sg.closePath();
  sg.fillPath(); sg.strokePath();
  scene.matter.add.gameObject(sg, shard);

  // kick the shard outward
  scene.matter.body.setVelocity(shard, { x: dir.x * 5, y: dir.y * 5 });
  scene.matter.body.setAngularVelocity(shard, 0.4);

  // --- Small debris bits ---
  for (let i = 0; i < 20; i++){
    const jitter = Phaser.Math.Vector2.RIGHT.clone().setToPolar(dir.angle() + Phaser.Math.FloatBetween(-0.4, 0.4), 1);
    const speed = Phaser.Math.FloatBetween(3, 7);
    const r = Phaser.Math.Between(2, 5);

    const bit = scene.matter.add.circle(pt.x + jitter.x*8, pt.y + jitter.y*8, r, {
      restitution: 0.2, friction: 0.05, frictionAir: 0.01, density: 0.0008
    });

    const color = 0xbfe1ff;
    const circ = scene.add.circle(bit.position.x, bit.position.y, r, color);
    scene.matter.add.gameObject(circ, bit);

    scene.matter.body.setVelocity(bit, { x: jitter.x * speed, y: jitter.y * speed });
    scene.matter.body.setAngularVelocity(bit, Phaser.Math.FloatBetween(-0.3, 0.3));
  }
}

function drawCrater(scene, pt){
  // Draw a little â€œcraterâ€ on the planet texture surface (overlay)
  const crt = scene.add.graphics();
  crt.fillStyle(0x0a1733, 0.6);
  crt.fillCircle(pt.x, pt.y, 20);
  crt.lineStyle(3, 0x14315f, 0.7);
  crt.strokeCircle(pt.x, pt.y, 20);
}

function thudFlash(scene, pt){
  const f = scene.add.circle(pt.x, pt.y, 10, 0xffd166, 0.9);
  scene.tweens.add({
    targets: f,
    alpha: 0,
    scale: 3,
    duration: 220,
    onComplete: () => f.destroy()
  });
}

function drawWeakSector(){
  // purely visual helper ring sector to hint where to click (subtle)
  const ring = this.add.graphics();
  ring.lineStyle(6, 0xffe28a, 0.35);
  ring.beginPath();
  ring.arc(planet.x, planet.y, planet.r * 0.95, weak.start, weak.end, false);
  ring.strokePath();

  // optional dot at the sector mid
  const mid = (weak.start + (weak.end < weak.start ? weak.end + Math.PI*2 : weak.end)) / 2;
  const px = planet.x + Math.cos(mid) * planet.r * 0.92;
  const py = planet.y + Math.sin(mid) * planet.r * 0.92;
  this.add.circle(px, py, 4, 0xffe28a, 0.8);
}

function rotateVec(x, y, ang){
  const v = new Phaser.Math.Vector2(x,y);
  v.rotate(ang);
  return v;
}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Phaser – Two Globes Bounce</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 900,
  height: 560,
  backgroundColor: '#0b1b2b',
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { y: 0 },
      debug: false
    }
  },
  scene: { preload, create, update }
};
new Phaser.Game(config);

let globeA, globeB, label;

function preload() {
  // Create a glossy globe texture (64x64) so we don’t rely on external images.
  const g = this.add.graphics();
  // base
  g.fillStyle(0x66c2ff, 1).fillCircle(32, 32, 30);
  // highlight
  g.fillStyle(0xffffff, 0.35).fillCircle(22, 22, 12);
  // rim
  g.lineStyle(3, 0x3aa0e0, 1).strokeCircle(32, 32, 30);
  g.generateTexture('globe', 64, 64);
  g.destroy();
}

function create() {
  const W = this.scale.width, H = this.scale.height;

  // Add two physics images (balls)
  globeA = this.physics.add.image(W * 0.33, H * 0.45, 'globe');
  globeB = this.physics.add.image(W * 0.67, H * 0.55, 'globe');

  // Make them round and elastic
  [globeA, globeB].forEach(ball => {
    // Set a circular body that matches the 64x64 texture nicely
    ball.body.setCircle(30);      // radius
    ball.body.setOffset(2, 2);    // center circle inside the 64x64 image
    ball.setBounce(1, 1);         // perfectly elastic collisions
    ball.setCollideWorldBounds(true);
  });

  // Different starting speeds/directions
  globeA.setVelocity(220, -160);
  globeB.setVelocity(-180, 200);

  // Collide *with each other*
  this.physics.add.collider(globeA, globeB);

  // HUD
  label = this.add.text(16, 16,
    'Two globes bouncing: walls + each other\nClick anywhere to nudge a random globe.',
    { fontFamily: 'Arial, Helvetica, sans-serif', fontSize: '16px', color: '#bfe9ff' }
  );

  // Click to give a little random “nudge” impulse (fun to test angles)
  this.input.on('pointerdown', (p) => {
    const target = Math.random() < 0.5 ? globeA : globeB;
    const angle = Phaser.Math.Angle.Between(target.x, target.y, p.worldX, p.worldY);
    const speed = 240;
    target.setVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed);
  });

  // Optional: keep speed stable (avoid tiny numeric drift)
  this.time.addEvent({
    delay: 1000,
    loop: true,
    callback: () => normalizeSpeed(globeA, 270) || normalizeSpeed(globeB, 270)
  });
}

function update() {
  // Nothing required each frame; Arcade handles collisions + wall bounces.
}

// Helper to keep total speed near a target (nice for classroom demos)
function normalizeSpeed(ball, target) {
  const v = ball.body.velocity;
  const cur = Math.hypot(v.x, v.y) || 1;
  const scale = target / cur;
  if (Math.abs(cur - target) > 1) {
    ball.setVelocity(v.x * scale, v.y * scale);
    return true;
  }
  return false;
}
</script>
</body>
</html>
